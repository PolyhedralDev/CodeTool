{
  parserClass="org.everbuild.terrascript.parsing.TerrascriptParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Terrascript"
  psiImplClassSuffix="Impl"
  psiPackage="org.everbuild.terrascript.psi"
  psiImplPackage="org.everbuild.terrascript.psi.impl"
  elementTypeHolderClass="org.everbuild.terrascript.psi.TesfTypes"
  elementTypeClass="org.everbuild.terrascript.parsing.TerrascriptElementType"
  tokenTypeClass="org.everbuild.terrascript.parsing.TerrascriptTokenType"

  // We add 'LBRACE' to the recovery set to help with unterminated blocks.
  recoverWhile="!statement_start_or_brace"
  // This helps make parsing more efficient by not creating PSI nodes for simple intermediate rules.
  extraRoot("statement")="true"

  tokens = [
    IF = "if"
    ELSE = "else"
    WHILE = "while"
    FOR = "for"

    RETURN = "return"
    FAIL = "fail"
    BREAK = "break"
    CONTINUE = "continue"

    TRUE = "true"
    FALSE = "false"
    STR = "str"
    NUM = "num"
    BOOL = "bool"

    // Literals
    NUMBER = "regexp:[0-9]+(\\.[0-9]+)?"
    STRING = "regexp:\"([^\"]|\\.)*\""

    // Identifiers
    ID = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Punctuation
    EQ = "="
    SEMICOLON = ";"
    COMMA = ","
    LPAREN = "("
    RPAREN = ")"
    LBRACE = "{"
    RBRACE = "}"

    // Operators
    L_AND = "&&"
    L_OR = "||"
    L_NOT = "!"
    PLUS = "+"
    MINUS = "-"
    MUL = "*"
    DIV = "/"
    MOD = "%"
    EQEQ = "=="
    NEQ = "!="
    LT = "<"
    GT = ">"
    LE = "<="
    GE = ">="

    // Comments
    COMMENT = "regexp://[^\r\n]*"

    // Implicit rule for intellij
//    space = 'regexp:\s+'
  ]
}

terrascriptFile ::= statement*

// This "meta" rule helps the parser know what can start a statement.
// It's used by `recoverWhile` for better error handling.
private meta statement_start_or_brace ::= statement_start | LBRACE
private meta statement_start ::= (STR | NUM | BOOL | ID | IF | FOR | WHILE | RETURN | FAIL | BREAK | CONTINUE | COMMENT | LPAREN)

// The main statement rule. Notice it's marked as 'private'.
// This makes the generated PSI tree cleaner.
private statement ::= (
    variable_declaration SEMICOLON
    | id_assignment SEMICOLON
    | expression SEMICOLON
    | conditional
    | while_loop
    | for_loop
    | control_flow_statement SEMICOLON
    | block
    | COMMENT
    | SEMICOLON // Allow empty statements
)

block ::= LBRACE statement* RBRACE

// --- Statements ---
// We add 'pin=ID' and 'pin=EQ'. This tells the parser: once you see the identifier
// (or equals sign), commit to this rule. This dramatically improves error recovery.
variable_declaration ::= vartype ID assignment? {pin=2}
id_assignment ::= ID EQ expression {pin=2}
assignment ::= EQ expression

control_flow_statement ::= RETURN | FAIL | BREAK | CONTINUE

conditional ::= if_statement (ELSE if_statement else_block?)*
if_statement ::= IF expression block
else_block ::= ELSE block // for a standalone else

while_loop ::= WHILE expression block
for_loop ::= FOR LPAREN for_initializer? SEMICOLON expression? SEMICOLON for_update? RPAREN block

private for_initializer ::= variable_declaration | expression
private for_update ::= expression

// --- Expressions ---
// This is the new, robust expression parsing structure. It correctly handles
// operator precedence and associativity, and avoids the dangerous right-recursion.
expression ::= logical_or_expression
private logical_or_expression ::= logical_and_expression (L_OR logical_and_expression)*
private logical_and_expression ::= equality_expression (L_AND equality_expression)*
private equality_expression ::= relational_expression ((EQEQ | NEQ) relational_expression)*
private relational_expression ::= additive_expression ((LT | GT | LE | GE) additive_expression)*
private additive_expression ::= multiplicative_expression ((PLUS | MINUS) multiplicative_expression)*
private multiplicative_expression ::= unary_expression ((MUL | DIV | MOD) unary_expression)*
private unary_expression ::= (MINUS | L_NOT) unary_expression | call_expression

private call_expression ::= primary_expression (LPAREN argument_list? RPAREN)* // Function call suffix

private primary_expression ::= literal | ID | LPAREN expression RPAREN

argument_list ::= expression (COMMA expression)*
literal ::= NUMBER | STRING | TRUE | FALSE
vartype ::= STR | NUM | BOOL
