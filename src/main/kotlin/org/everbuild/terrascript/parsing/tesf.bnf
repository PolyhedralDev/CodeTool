{
  parserClass="org.everbuild.terrascript.parsing.TerrascriptParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Terrascript"
  psiImplClassSuffix="Impl"
  psiPackage="org.everbuild.terrascript.psi"
  psiImplPackage="org.everbuild.terrascript.psi.impl"
  psiImplUtilClass="org.everbuild.terrascript.psi.TerrascriptPsiUtil"
  elementTypeHolderClass="org.everbuild.terrascript.psi.TesfTypes"
  elementTypeClass="org.everbuild.terrascript.parsing.TerrascriptElementType"
  tokenTypeClass="org.everbuild.terrascript.parsing.TerrascriptTokenType"

  recoverWhile="!statement_start_or_brace"

  tokens = [
    IF = "if"
    ELSE = "else"
    WHILE = "while"
    FOR = "for"

    RETURN = "return"
    FAIL = "fail"
    BREAK = "break"
    CONTINUE = "continue"

    TRUE = "true"
    FALSE = "false"
    STR = "str"
    NUM = "num"
    BOOL = "bool"

    // Literals
    NUMBER = "regexp:[0-9]+(\.[0-9]+)?"
    STRING = "regexp:\"([^\"]|\\.)*\""

    // Identifiers
    ID = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Punctuation
    EQ = "="
    SEMICOLON = ";"
    COMMA = ","
    LPAREN = "("
    RPAREN = ")"
    LBRACE = "{"
    RBRACE = "}"

    // Operators
    L_AND = "&&"
    L_OR = "||"
    L_NOT = "!"
    PLUS = "+"
    MINUS = "-"
    MUL = "*"
    DIV = "/"
    MOD = "%"
    EQEQ = "=="
    NEQ = "!="
    LT = "<"
    GT = ">"
    LE = "<="
    GE = ">="

    // Comments
    COMMENT = "regexp://[^\r\n]*"

    // Implicit rule for intellij
//    space = 'regexp:\s+'
  ]
}

terrascriptFile ::= statement*

// This "meta" rule helps the parser know what can start a statement.
// It's used by `recoverWhile` for better error handling.
private meta statement_start_or_brace ::= statement_start | LBRACE
private meta statement_start ::= (STR | NUM | BOOL | ID | IF | FOR | WHILE | RETURN | FAIL | BREAK | CONTINUE | COMMENT | LPAREN)

statement ::= (
    variable_declaration SEMICOLON
    | id_assignment SEMICOLON
    | expression SEMICOLON
    | conditional
    | while_loop
    | for_loop
    | control_flow_statement SEMICOLON
    | COMMENT
    | SEMICOLON // Allow empty statements
)

block ::= (LBRACE statement* RBRACE) | statement

// --- Statements ---
variable_declaration ::= vartype ID assignment? {
    pin=2
    mixin="TerrascriptNamedElementImpl"
    implements="TerrascriptNamedElement"
    methods=[getName setName getNameIdentifier]
}
id_assignment ::= ID EQ expression {pin=2}
assignment ::= EQ expression

control_flow_statement ::= RETURN | FAIL | BREAK | CONTINUE

conditional ::= if_statement (ELSE if_statement)* else_block?
if_statement ::= IF LPAREN expression RPAREN block
else_block ::= ELSE block // for a standalone else

while_loop ::= WHILE LPAREN expression RPAREN block
for_loop ::= FOR LPAREN for_initializer? SEMICOLON expression? SEMICOLON for_update? RPAREN block

private for_initializer ::= variable_declaration | expression
private for_update ::= id_assignment | expression

// --- Expressions ---
expression ::= logical_or_expression
private logical_or_expression ::= logical_and_expression (L_OR logical_and_expression)*
private logical_and_expression ::= equality_expression (L_AND equality_expression)*
private equality_expression ::= relational_expression ((EQEQ | NEQ) relational_expression)*
private relational_expression ::= additive_expression ((LT | GT | LE | GE) additive_expression)*
private additive_expression ::= multiplicative_expression ((PLUS | MINUS) multiplicative_expression)*
private multiplicative_expression ::= unary_expression ((MUL | DIV | MOD) unary_expression)*
private unary_expression ::= (MINUS | L_NOT) unary_expression | element_call_expression
private element_call_expression ::= call_expression | primary_expression

call_expression ::= ID LPAREN argument_list? RPAREN

private primary_expression ::= literal | ID | LPAREN expression RPAREN

argument_list ::= expression (COMMA expression)*
literal ::= NUMBER | STRING | TRUE | FALSE
vartype ::= STR | NUM | BOOL
